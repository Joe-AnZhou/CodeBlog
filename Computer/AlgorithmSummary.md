# Algorithm summary


最近在断断续续的看一些算法的东西。算法这个东西在高级的工程师的面试中是不可获取的，所以也来记录一下。

## 基础

这一部分是对算法理解中需要的基础知识。

### 时间复杂度

时间复杂度简单的理解是**计算的次数或者是消耗的时间**。是判定一个特算法优劣的指标之一。目前一种比较通用的表示法就是「 **大O符号表示法** 」，即 **算法的渐进时间复杂度：**T(n) = O(f(n))。

- f(n)：表示每行代码执行的次数。 
- O ：表示正比例关系。

因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的，所以我们可以简化公式为：**T(n) = O(n)**

我们看线图理解一下一般的一些时间复杂度。

![时间复杂度](./images/on.png '时间复杂度')

常见的时间复杂度量级有：

- 常数阶O(1)： 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)。
- 对数阶O(logN)：当循环 log2^n 次以后，代码就结束了。因此这个代码的时间复杂度为：**O(logn)**
- 线性阶O(n)：它消耗的时间是随着n的变化而变化的
- 线性对数阶O(nlogN)：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)
- 平方阶O(n²)：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了
- 立方阶O(n³)
- 指数阶(2^n)
- K次方阶O(n^k):  就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)
  如果将循环的层数改成k，那么时间复杂度就变成了O(n^k)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。下面是几个简单是示例

```js
// O(1)复杂度的运算
var n = 1 
console.log(n);
// O(N) 复杂度的运算 
for (let i= 0; i< n; i++) {
  // 当前循环会循环N次
}
// O(N^2) 复杂度的运算
for (let i= 0; i< n; i++) {
  for (let i= 0; i< n; i++) {
     // 当前循环会循环N*N次
  }
}
```

### 空间复杂度

空间复杂度是用来衡量计算程序中实际占用的空间的。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度比较常用的有：

O(1)：如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

O(n)：，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)。

